!$Revision: 1.1.1.1 $
!$Date: 2010/03/23 15:27:26 $
!$RCSfile: run.cns,v $

module(
spectrum;
filenames;
spectra;
data;
iterations;
saprotocol;
refine;
relax;
toppar; 
analysis;
)

{+ file: run.cns +}
{+ description: The file run.cns contains all necessary information to run ARIA. ARIA automatically sets the default values.
Please change the values for the mixing time, rotation 
correlation time and spectrometer frequency for the spin diffusion correction.
For the large CNS log files, you should use a temporary directory. version 1.2 +}
{+ authors: Jens Linge, Michael Nilges +}

set message on echo on end

! Please cite the following references when using this protocol: 
{+ reference: M. Nilges (1995) Calculation of protein structures with ambiguous distance restraints. Automated assignment of ambiguous NOE crosspeaks and disulphide connectivities. J. Mol. Biol. 245, 645-660 +}
{+ reference: M. Nilges and Sean O'Donoghue (1998) Ambiguous NOEs and automated NOE assignment. Prog. NMR Spect. 32, 107-139 +}
{+ reference: J.P. Linge and M. Nilges (1999) Influence of non-bonded parameters on the quality of NMR structures: a new force-field for NMR structure calculation. J. Biomol. NMR 13, 51-59 +}
{+ reference:        J.P. Linge (2001) New methods for automated NOE assignment and NMR structure calculation. Book on Demand Verlag        ISBN: 383111482X  +}
{+ reference:        J.P. Linge, S.I. O'Donoghue and M. Nilges (2001). Assigning Ambiguous NOEs with ARIA. 
       Methods in Enzymology, 339, 71-90. +}

{- Guidelines for using this file:
   - all strings must be quoted by double-quotes
   - logical variables (true/false) are not quoted
   - do not remove any evaluate statements from the file
   - pathnames should not exceed 80 characters -}


{========================= new stuff for aria2 =========================}

evaluate (&data.count=%(counter)d)
evaluate (&data.iteration=%(iteration)d)


{* starting structure for structure generation *}
evaluate (&data.initial_pdb="PATHPDB:%(initial_pdb)s")

evaluate (&data.randomize_mainchain=%(randomize_mainchain)s)
! BARDIAUX 2.3
evaluate (&data.use_template=%(use_template)s)

{======================= filenames =========================}

{*  the name of your current project *}
evaluate (&filenames.fileroot="%(file_root)s")

evaluate (&filenames.outdir="NEWIT:")
evaluate (&filenames.reference=&reference)
evaluate (&filenames.template=&filenames.fileroot + "_template.pdb")

{* molecular topology files (mtf) *}
{* will be generated by ARIA from the sequence / add other mtf files here *}
evaluate (&filenames.structure  ="%(psf_file)s")
evaluate (&filenames.structure_1="%(psf_file)s")
evaluate (&filenames.structure_2="")
evaluate (&filenames.structure_3="")
evaluate (&filenames.structure_4="")
evaluate (&filenames.structure_5="")

{* PDB or sequence (3-letter code) file*}
{+ choice: "PDB" "sequence" +}
evaluate (&toppar.pdb_or_sequence="PDB")
evaluate (&toppar.prot_coor_1="%(sequence_pdb)s")

{* new segment id (segid) *}
{* will appear in the pdb files, must have 4 digits, leave it blank if you don't want one *}
evaluate (&toppar.prot_segid_1="%(segid_1)s")
evaluate (&toppar.prot_segid_2="%(segid_2)s")
evaluate (&toppar.prot_segid_3="%(segid_3)s")
evaluate (&toppar.prot_segid_4="%(segid_4)s")
evaluate (&toppar.prot_segid_5="%(segid_5)s")

{* symmetry definition for dimers  ; modified by Benjamin Bardiaux 22/10/04 *}
evaluate (&toppar.symmetry="%(symmetry)s")
evaluate (&toppar.mononum=%(mononum)d)

!if (&toppar.symmetry eq "1") then
!   evaluate (&toppar.mononum = 1)
!elseif (&toppar.symmetry eq "2") then
!   evaluate (&toppar.mononum = 2)
!end if


{===================== topology and parameter files ======================}

{* topology file *}
evaluate (&toppar.prot_top_1="%(topology_file_1)s")
evaluate (&toppar.prot_top_2="%(topology_file_2)s")

{* linkage file *}
evaluate (&toppar.prot_link_1="%(linkage_file_1)s")
evaluate (&toppar.prot_link_2="%(linkage_file_2)s")

{* energy parameter file *}
evaluate (&toppar.prot_par_1="%(parameter_file_1)s")
evaluate (&toppar.prot_par_2="%(parameter_file_2)s")
evaluate (&toppar.prot_par_3="")
evaluate (&toppar.prot_par_4="")
evaluate (&toppar.prot_par_5="")

{* type of non-bonded parameters *}
{* specify the type of non-bonded interaction *}
{+ choice: "PROLSQ" "PARMALLH6" "PARALLHDG" "OPLSX" +}
evaluate (&toppar.par_nonbonded="%(nonbonded_parameters)s")

if (&toppar.prot_top_1 eq "topallhdg5.3soft.pro") then
    evaluate (&toppar.softfield="YES")
else
    evaluate (&toppar.softfield="NO")
end if

{=======aria 2.2========= symmetry restraints ==============================}

{+ table: rows=2 "packing" "ncs" +}
{+        cols=2 "use?" "k" +}

evaluate (&data.packing.on=%(packing_enabled)s)
evaluate (&data.packing_lastIt=%(last_iteration_packing)d)
evaluate (&data.packing_hot=%(k_packing_hot)f)
evaluate (&data.packing_cool1=%(k_packing_cool1)f)
evaluate (&data.packing_cool2=%(k_packing_cool2)f)

evaluate (&data.ncs.on=%(ncs_enabled)s)
evaluate (&data.ncs_k=%(k_ncs)f)
evaluate (&data.flags.ncs=%(ncs_enabled)s)

{=========================== Distance restraints  ========================}

evaluate(&data.nrestraints=%(nrestraints)d)

{* energy constants *}

{+ table: rows=3 "unambig" "ambig" "hbonds" +}
{+        cols=5 "firstIteration" "hot" "cool1_ini" "cool1_fin" "cool2" +}

evaluate (&data.unamb_firstit=%(unambig_first_iteration)d)
evaluate (&data.unamb_hot=%(unambig_k_hot)f)
evaluate (&data.unamb_cool1_ini=%(unambig_k_cool1_initial)f)
evaluate (&data.unamb_cool1_fin=%(unambig_k_cool1_final)f)
evaluate (&data.unamb_cool2=%(unambig_k_cool2)f)

evaluate (&data.amb_firstit=%(ambig_first_iteration)d)
evaluate (&data.amb_hot=%(ambig_k_hot)f)
evaluate (&data.amb_cool1_ini=%(ambig_k_cool1_initial)f)
evaluate (&data.amb_cool1_fin=%(ambig_k_cool1_final)f)
evaluate (&data.amb_cool2=%(ambig_k_cool2)f)

evaluate (&data.hbond_firstit=%(hbond_first_iteration)d)
evaluate (&data.hbond_hot=%(hbond_k_hot)f)
evaluate (&data.hbond_cool1_ini=%(hbond_k_cool1_initial)f)
evaluate (&data.hbond_cool1_fin=%(hbond_k_cool1_final)f)
evaluate (&data.hbond_cool2=%(hbond_k_cool2)f)

{* potential shape *}

{+ table: rows=4 "mRswitch" "rswitch" "mAsymptote" "asymptote" +}
{+        cols=3 "hot" "cool1" "cool2" +}

evaluate (&data.mrswi_hot=%(fbhw_m_rswitch_hot)f)
evaluate (&data.mrswi_cool1=%(fbhw_m_rswitch_cool1)f)
evaluate (&data.mrswi_cool2=%(fbhw_m_rswitch_cool2)f)

evaluate (&data.rswi_hot=%(fbhw_rswitch_hot)f)
evaluate (&data.rswi_cool1=%(fbhw_rswitch_cool1)f)
evaluate (&data.rswi_cool2=%(fbhw_rswitch_cool2)f)

evaluate (&data.masy_hot=%(fbhw_m_asymptote_hot)f)
evaluate (&data.masy_cool1=%(fbhw_m_asymptote_cool1)f)
evaluate (&data.masy_cool2=%(fbhw_m_asymptote_cool2)f)

evaluate (&data.asy_hot=%(fbhw_asymptote_hot)f)
evaluate (&data.asy_cool1=%(fbhw_asymptote_cool1)f)
evaluate (&data.asy_cool2=%(fbhw_asymptote_cool2)f)

{====================== Log-Harmonic potential  ======================}
{* BERNARD 2.3 *}
{* use log-harmonic potential for the cool2 step *}
{+ choice: "yes" "no" +}
evaluate (&data.logharmonic.on=%(logharmonic_enabled)s)

{* use automatic weight for the log-harmonic potential *}
{+ choice: "yes" "no" +}
evaluate (&data.logharmonic.auto_weight=%(logharmonic_use_auto_weight)s)

{* weight value for the log-harmonic potential, if AutoWeight is disabled *}
{+ choice: Positive Float +}
evaluate (&data.logharmonic.weight_unambig=%(logharmonic_weight_unambig)f)
evaluate (&data.logharmonic.weight_ambig=%(logharmonic_weight_ambig)f)
evaluate (&data.logharmonic.weight_hbond=%(logharmonic_weight_hbond)f)


{=========================== dihedrals ==============================}

{* energy constants *}
{+ table: rows=1 "dihedrals" cols=4 "use?" "hot" "cool1" "cool2" +}

evaluate (&data.dihedrals.on=%(dihedral_enabled)s)
evaluate (&data.dihedrals_hot=%(dihedral_k_hot)f)
evaluate (&data.dihedrals_cool1=%(dihedral_k_cool1)f)
evaluate (&data.dihedrals_cool2=%(dihedral_k_cool2)f)

evaluate (&data.flags.cdih=%(dihedral_enabled)s)
evaluate (&data.cdih.on=%(dihedral_enabled)s)

{* Do you want to use hbond restraints? *}
{+ choice: true false +}

evaluate (&data.hbonds_on=%(hbond_enabled)s)

{* Do you want to use ssbond restraints? *}
{+ choice: true false +}

evaluate (&data.ssbonds.on=%(ssbonds_enabled)s)

{=========================== CSI restraints ==============================}
{* Do you want to use CSI derived hbond restraints? *}
{* uses the files generated by the program CSI *}
{+ choice: true false +}

evaluate (&data.hbondscsi_on=%(hbond_csi_enabled)s)

{* Do you want to use CSI derived dihedral restraints? *}
{+ choice: true false +}

evaluate (&data.dihedralscsi.on=%(dihedral_csi_enabled)s)
evaluate (&data.cdihcsi.on=%(dihedral_csi_enabled)s)

{=========================== TALOS restraints ==============================}
{* Do you want to use TALOS derived dihedral restraints? *}
{+ choice: true false +}

evaluate (&data.dihedralstalos.on=%(dihedral_talos_enabled)s)
evaluate (&data.cdihtalos.on=%(dihedral_talos_enabled)s)

{=========================== Karplus coupling restraints ====================}

{* Karplus coefficients *}
{+ table: rows=5 "class1" "class2" "class3" "class4" "class5" +} 
{+        cols=8 "use?" "A" "B" "C" "delta" "E(hot)" "E(cool1)" "E(cool2)" +}

evaluate (&data.c1_on=%(c1_enabled)s)
evaluate (&data.c1_karplusa=%(c1_a)f)
evaluate (&data.c1_karplusb=%(c1_b)f)
evaluate (&data.c1_karplusc=%(c1_c)f)
evaluate (&data.c1_karplusd=%(c1_d)f)
evaluate (&data.c1_hot=%(c1_k_hot)f)
evaluate (&data.c1_cool1=%(c1_k_cool1)f)
evaluate (&data.c1_cool2=%(c1_k_cool2)f)

evaluate (&data.c2_on=%(c2_enabled)s)
evaluate (&data.c2_karplusa=%(c2_a)f)
evaluate (&data.c2_karplusb=%(c2_b)f)
evaluate (&data.c2_karplusc=%(c2_c)f)
evaluate (&data.c2_karplusd=%(c2_d)f)
evaluate (&data.c2_hot=%(c2_k_hot)f)
evaluate (&data.c2_cool1=%(c2_k_cool1)f)
evaluate (&data.c2_cool2=%(c2_k_cool2)f)

evaluate (&data.c3_on=%(c3_enabled)s)
evaluate (&data.c3_karplusa=%(c3_a)f)
evaluate (&data.c3_karplusb=%(c3_b)f)
evaluate (&data.c3_karplusc=%(c3_c)f)
evaluate (&data.c3_karplusd=%(c3_d)f)
evaluate (&data.c3_hot=%(c3_k_hot)f)
evaluate (&data.c3_cool1=%(c3_k_cool1)f)
evaluate (&data.c3_cool2=%(c3_k_cool2)f)

evaluate (&data.c4_on=%(c4_enabled)s)
evaluate (&data.c4_karplusa=%(c4_a)f)
evaluate (&data.c4_karplusb=%(c4_b)f)
evaluate (&data.c4_karplusc=%(c4_c)f)
evaluate (&data.c4_karplusd=%(c4_d)f)
evaluate (&data.c4_hot=%(c4_k_hot)f)
evaluate (&data.c4_cool1=%(c4_k_cool1)f)
evaluate (&data.c4_cool2=%(c4_k_cool2)f)

evaluate (&data.c5_on=%(c5_enabled)s)
evaluate (&data.c5_karplusa=%(c5_a)f)
evaluate (&data.c5_karplusb=%(c5_b)f)
evaluate (&data.c5_karplusc=%(c5_c)f)
evaluate (&data.c5_karplusd=%(c5_d)f)
evaluate (&data.c5_hot=%(c5_k_hot)f)
evaluate (&data.c5_cool1=%(c5_k_cool1)f)
evaluate (&data.c5_cool2=%(c5_k_cool2)f)

{=========================== residual dipolar couplings ======================}

{* Parameters *}
{+ table: rows=5 "class1" "class2" "class3" "class4" "class5" +}
{+        cols=19 "type" "firstIt" "E(hot)" "E(cool1)" "E(cool2)" "R" "D" "ini_bor_hot" "fin_bor_hot" "ini_bor_cool1" "fin_bor_cool1" "ini_bor_cool2" "fin_bor_cool2" "ini_cen_hot" "fin_cen_hot" "ini_cen_cool1" "fin_cen_cool1" "ini_cen_cool2" "fin_cen_cool2"  +}
{+ choice: "NO" "SANI" "VANGLE" +}

evaluate (&data.rdc1_on=%(rdc1_enabled)s)
evaluate (&data.rdc1_choice="%(rdc1_method)s")

if (&data.rdc1_on eq false) then
  evaluate (&data.rdc1_choice = "NO")
end if

evaluate (&data.rdc1_firstIt=%(rdc1_first_iteration)d)
evaluate (&data.rdc1_hot=%(rdc1_k_hot)f)
evaluate (&data.rdc1_cool1=%(rdc1_k_cool1)f)
evaluate (&data.rdc1_cool2=%(rdc1_k_cool2)f)
evaluate (&data.rdc1_r=%(rdc1_r)f)
evaluate (&data.rdc1_d=%(rdc1_d)f)

evaluate (&data.ini_bor_hot_1=%(rdc1_border_hot_initial)f)
evaluate (&data.ini_bor_cool1_1=%(rdc1_border_cool1_initial)f)
evaluate (&data.ini_bor_cool2_1=%(rdc1_border_cool2_initial)f)

evaluate (&data.ini_cen_hot_1=%(rdc1_center_hot_initial)f)
evaluate (&data.ini_cen_cool1_1=%(rdc1_center_cool1_initial)f)
evaluate (&data.ini_cen_cool2_1=%(rdc1_center_cool2_initial)f)

evaluate (&data.fin_bor_hot_1=%(rdc1_border_hot_final)f)
evaluate (&data.fin_bor_cool1_1=%(rdc1_border_cool1_final)f)
evaluate (&data.fin_bor_cool2_1=%(rdc1_border_cool2_final)f)

evaluate (&data.fin_cen_hot_1=%(rdc1_center_hot_final)f)
evaluate (&data.fin_cen_cool1_1=%(rdc1_center_cool1_final)f)
evaluate (&data.fin_cen_cool2_1=%(rdc1_center_cool2_final)f)

evaluate (&data.rdc2_on=%(rdc2_enabled)s)
evaluate (&data.rdc2_choice="%(rdc2_method)s")

if (&data.rdc2_on eq false) then
  evaluate (&data.rdc2_choice = "NO")
end if

evaluate (&data.rdc2_firstIt=%(rdc2_first_iteration)d)
evaluate (&data.rdc2_hot=%(rdc2_k_hot)f)
evaluate (&data.rdc2_cool1=%(rdc2_k_cool1)f)
evaluate (&data.rdc2_cool2=%(rdc2_k_cool2)f)
evaluate (&data.rdc2_r=%(rdc2_r)f)
evaluate (&data.rdc2_d=%(rdc2_d)f)

evaluate (&data.ini_bor_hot_2=%(rdc2_border_hot_initial)f)
evaluate (&data.ini_bor_cool1_2=%(rdc2_border_cool1_initial)f)
evaluate (&data.ini_bor_cool2_2=%(rdc2_border_cool2_initial)f)

evaluate (&data.ini_cen_hot_2=%(rdc2_center_hot_initial)f)
evaluate (&data.ini_cen_cool1_2=%(rdc2_center_cool1_initial)f)
evaluate (&data.ini_cen_cool2_2=%(rdc2_center_cool2_initial)f)

evaluate (&data.fin_bor_hot_2=%(rdc2_border_hot_final)f)
evaluate (&data.fin_bor_cool1_2=%(rdc2_border_cool1_final)f)
evaluate (&data.fin_bor_cool2_2=%(rdc2_border_cool2_final)f)

evaluate (&data.fin_cen_hot_2=%(rdc2_center_hot_final)f)
evaluate (&data.fin_cen_cool1_2=%(rdc2_center_cool1_final)f)
evaluate (&data.fin_cen_cool2_2=%(rdc2_center_cool2_final)f)

evaluate (&data.rdc3_on=%(rdc3_enabled)s)
evaluate (&data.rdc3_choice="%(rdc3_method)s")

if (&data.rdc3_on eq false) then
  evaluate (&data.rdc3_choice = "NO")
end if

evaluate (&data.rdc3_firstIt=%(rdc3_first_iteration)d)
evaluate (&data.rdc3_hot=%(rdc3_k_hot)f)
evaluate (&data.rdc3_cool1=%(rdc3_k_cool1)f)
evaluate (&data.rdc3_cool2=%(rdc3_k_cool2)f)
evaluate (&data.rdc3_r=%(rdc3_r)f)
evaluate (&data.rdc3_d=%(rdc3_d)f)

evaluate (&data.ini_bor_hot_3=%(rdc3_border_hot_initial)f)
evaluate (&data.ini_bor_cool1_3=%(rdc3_border_cool1_initial)f)
evaluate (&data.ini_bor_cool2_3=%(rdc3_border_cool2_initial)f)

evaluate (&data.ini_cen_hot_3=%(rdc3_center_hot_initial)f)
evaluate (&data.ini_cen_cool1_3=%(rdc3_center_cool1_initial)f)
evaluate (&data.ini_cen_cool2_3=%(rdc3_center_cool2_initial)f)

evaluate (&data.fin_bor_hot_3=%(rdc3_border_hot_final)f)
evaluate (&data.fin_bor_cool1_3=%(rdc3_border_cool1_final)f)
evaluate (&data.fin_bor_cool2_3=%(rdc3_border_cool2_final)f)

evaluate (&data.fin_cen_hot_3=%(rdc3_center_hot_final)f)
evaluate (&data.fin_cen_cool1_3=%(rdc3_center_cool1_final)f)
evaluate (&data.fin_cen_cool2_3=%(rdc3_center_cool2_final)f)

evaluate (&data.rdc4_on=%(rdc4_enabled)s)
evaluate (&data.rdc4_choice="%(rdc4_method)s")

if (&data.rdc4_on eq false) then
  evaluate (&data.rdc4_choice = "NO")
end if

evaluate (&data.rdc4_firstIt=%(rdc4_first_iteration)d)
evaluate (&data.rdc4_hot=%(rdc4_k_hot)f)
evaluate (&data.rdc4_cool1=%(rdc4_k_cool1)f)
evaluate (&data.rdc4_cool2=%(rdc4_k_cool2)f)
evaluate (&data.rdc4_r=%(rdc4_r)f)
evaluate (&data.rdc4_d=%(rdc4_d)f)

evaluate (&data.ini_bor_hot_4=%(rdc4_border_hot_initial)f)
evaluate (&data.ini_bor_cool1_4=%(rdc4_border_cool1_initial)f)
evaluate (&data.ini_bor_cool2_4=%(rdc4_border_cool2_initial)f)

evaluate (&data.ini_cen_hot_4=%(rdc4_center_hot_initial)f)
evaluate (&data.ini_cen_cool1_4=%(rdc4_center_cool1_initial)f)
evaluate (&data.ini_cen_cool2_4=%(rdc4_center_cool2_initial)f)

evaluate (&data.fin_bor_hot_4=%(rdc4_border_hot_final)f)
evaluate (&data.fin_bor_cool1_4=%(rdc4_border_cool1_final)f)
evaluate (&data.fin_bor_cool2_4=%(rdc4_border_cool2_final)f)

evaluate (&data.fin_cen_hot_4=%(rdc4_center_hot_final)f)
evaluate (&data.fin_cen_cool1_4=%(rdc4_center_cool1_final)f)
evaluate (&data.fin_cen_cool2_4=%(rdc4_center_cool2_final)f)

evaluate (&data.rdc5_on=%(rdc5_enabled)s)
evaluate (&data.rdc5_choice="%(rdc5_method)s")

if (&data.rdc5_on eq false) then
  evaluate (&data.rdc5_choice = "NO")
end if

evaluate (&data.rdc5_firstIt=%(rdc5_first_iteration)d)
evaluate (&data.rdc5_hot=%(rdc5_k_hot)f)
evaluate (&data.rdc5_cool1=%(rdc5_k_cool1)f)
evaluate (&data.rdc5_cool2=%(rdc5_k_cool2)f)
evaluate (&data.rdc5_r=%(rdc5_r)f)
evaluate (&data.rdc5_d=%(rdc5_d)f)

evaluate (&data.ini_bor_hot_5=%(rdc5_border_hot_initial)f)
evaluate (&data.ini_bor_cool1_5=%(rdc5_border_cool1_initial)f)
evaluate (&data.ini_bor_cool2_5=%(rdc5_border_cool2_initial)f)

evaluate (&data.ini_cen_hot_5=%(rdc5_center_hot_initial)f)
evaluate (&data.ini_cen_cool1_5=%(rdc5_center_cool1_initial)f)
evaluate (&data.ini_cen_cool2_5=%(rdc5_center_cool2_initial)f)

evaluate (&data.fin_bor_hot_5=%(rdc5_border_hot_final)f)
evaluate (&data.fin_bor_cool1_5=%(rdc5_border_cool1_final)f)
evaluate (&data.fin_bor_cool2_5=%(rdc5_border_cool2_final)f)

evaluate (&data.fin_cen_hot_5=%(rdc5_center_hot_final)f)
evaluate (&data.fin_cen_cool1_5=%(rdc5_center_cool1_final)f)
evaluate (&data.fin_cen_cool2_5=%(rdc5_center_cool2_final)f)

{======================= SA protocol =========================}

{* type of molecular dynamics *}
{+ choice: "torsion" "Cartesian" +}
evaluate (&data.whichMD="%(md_type)s")

{* initial seed for random number generator *}
{* change to get different initial velocities *}
evaluate (&saprotocol.iniseed=%(random_seed)d) 

{* initial temperature for TAD and Cartesian dynamics *}
evaluate (&saprotocol.carinit_t=%(cartesian_temp_high)f)
evaluate (&saprotocol.tadinit_t=%(tad_temp_high)f)

{* final temperature after first cooling step *}
evaluate (&saprotocol.final1_t=%(temp_cool1_final)f)

{* finale temperature after second cooling step *}
evaluate (&saprotocol.final2_t=%(temp_cool2_final)f)

{* Cartesian time step *}
evaluate (&saprotocol.timestep=%(timestep)f)

{* factor for timestep and number of steps in TAD *}
evaluate (&saprotocol.tadfactor=%(tad_timestep_factor)f)

{* initial number of MD steps *}
evaluate (&saprotocol.initiosteps=%(steps_high)d)

{* number of MD steps for refinement *}
!XX RefineSteps is not used any longer
evaluate (&saprotocol.refinesteps=%(steps_refine)d)
!XXXevaluate (&saprotocol.refinesteps=0)

{* number of MD steps during first cooling stage *}
evaluate (&saprotocol.cool1_steps=%(steps_cool1)d)

{* number of MD steps during second cooling stage *}
evaluate (&saprotocol.cool2_steps=%(steps_cool2)d)

{* first iteration for Cartesian refinement (after TAD) *}
evaluate (&saprotocol.cart_firstit=%(cartesian_first_iteration)d)

evaluate (&saprotocol.fbeta=20)
evaluate (&saprotocol.mass=100)
evaluate (&saprotocol.tempstep=50)

{=========================== disulphide bonds ==============================}

{* number of disulphide bridges *}
{* set to zero if none are present *}
evaluate (&toppar.ss_bridge=%(number_of_ssbridges)d)

{* unambiguous or ambiguous disulphide bridges *}
{* default: unambiguous *}
{+ choice: "unambiguous" "ambiguous" +}
evaluate (&toppar.ss_ambigunambig="unambiguous")

{* repeat the four lines for each disulfide bond *}
{* first pair of entries are the resid and segid of the first cysteine *}
{* second pair of entries are the resid id and segid of the second cysteine *}

%(ssbridges)s

{=============== Cys-patch for ambiguous disulfide bonds ===================}
{* BARDIAUX *}

{* number of cysteiness *}
{* set to zero if none are present *}
evaluate (&toppar.cyspatches=%(number_of_cyspatches)d)

{* unambiguous or ambiguous disulphide bridges *}
{* default: unambiguous *}
{+ choice: "unambiguous" "ambiguous" +}
evaluate (&toppar.ss_ambigunambig="%(ssbonds_ambig)s")

{* repeat the 2 lines for each cystein *}
{* first pair of entries are the resid and segid of the first cysteine *}

%(cyspatches)s

{=========================== histidine patches ==============================}

{* Patch to change doubly protonated HIS to singly protonated histidine (HD1)*}

evaluate (&toppar.hisd_patches=%(number_of_hisd_patches)d)

%(hisd_patches)s

{* Patch to change doubly protonated HIS to singly protonated histidine (HE2)*}

evaluate (&toppar.hise_patches=%(number_of_hise_patches)d)

%(hise_patches)s

{=========================== Zinc patches ==============================}
{* Aymeric BERNARD *}
{* Put here your zinc patch declaration *}
{* See the file ${ARIA2}/examples/nemo/run_patched.cns as example *}

evaluate (&toppar.ssss_patches=%(number_of_ssss_patches)d)
evaluate (&toppar.ssse_patches=%(number_of_ssse_patches)d)
evaluate (&toppar.sssd_patches=%(number_of_sssd_patches)d)

%(zn_patches)s

{==============================  DNA patches ==============================}
{* BARDIAUX *}
{* Patch to DEOX *}
evaluate (&toppar.dna_chains=%(number_of_dna_chains)d)

%(dna_chains)s

{=========================== cis-pro patches ==============================}
{* BARDIAUX *}
{* Patch to change trans-proline into cis-pro*}

evaluate (&toppar.cispro_patches=%(number_of_cispro_patches)d)

%(cispro_patches)s


{* Atomname nomenclature *}
{* set true if you have IUPAC (e.g. LEU HB2 and HB3 and not HB2 and HB1) data (e.g. from XEASY) *}
{+ choice: true false +}
evaluate (&toppar.xplortodiana=false)

{* Do you want to use floating chirality assignment (swapping)? *}
{+ choice: true false +}
evaluate (&toppar.float=%(floating_assignment)s)

!Dihedrals, Jcouplings, Residual dipolar couplints, Hbonds,:

evaluate (&Data.flags.bonds = "TRUE")
evaluate (&Data.flags.angle = "TRUE")
evaluate (&Data.flags.impro = "TRUE")
evaluate (&Data.flags.dihed = "TRUE")
evaluate (&Data.flags.vdw   = "TRUE")
evaluate (&Data.flags.elec  = "FALSE")

evaluate (&Data.flags.noe  =  "TRUE")

evaluate (&Data.flags.coup =  "FALSE")
evaluate (&Data.flags.vean =  "FALSE")
evaluate (&Data.flags.sani =  "FALSE")
evaluate (&Data.flags.dani =  "FALSE")

evaluate (&Data.flags.plan =  "FALSE")
!evaluate (&Data.flags.ncs  =  "FALSE")

!water refinement
evaluate (&refine.write_water=%(write_solvent_molecules)s)

!for the non-bonded parameters (the section was taken out of 
!parallhdg5.0.pro and parallhdg5.1.pro, so be careful!):

if (&toppar.par_nonbonded eq "PROLSQ") then
    evaluate (&toppar.repel_radius = 1.0)
    evaluate (&toppar.repel_rcons = 20)
    evaluate (&toppar.repel_rexpo  = 4)
    evaluate (&toppar.repel_irexp  = 1)

elseif (&toppar.par_nonbonded eq "PARMALLH6") then
    evaluate (&toppar.repel_radius = 0.8)
    evaluate (&toppar.repel_rcons = 5.0)
    evaluate (&toppar.repel_rexpo  = 2)
    evaluate (&toppar.repel_irexp  = 2)

elseif (&toppar.par_nonbonded eq "OPLSX") then
    evaluate (&toppar.repel_radius = 0.0)

else        {...now the standard PARALLHDG parameters}
    evaluate (&toppar.repel_radius = 0.78)
    evaluate (&toppar.repel_rcons = 5.0)
    evaluate (&toppar.repel_rexpo  = 2)
    evaluate (&toppar.repel_irexp  = 2)

end if

!free R-factor:
!ARIA2 evaluate (&analysis.on=&rfree_on)
!ARIA2 evaluate (&analysis.oneset=&rfree_oneset)
!ARIA2 evaluate (&analysis.method=&rfree_method)
!ARIA2 evaluate (&analysis.percent=&rfree_percent)
!ARIA2 evaluate (&analysis.signal1=&rfree_signal1)
!ARIA2 evaluate (&analysis.signal2=&rfree_signal2)
!ARIA2 evaluate (&analysis.putative1=&rfree_putative1)
!ARIA2 evaluate (&analysis.putative2=&rfree_putative2)
!ARIA2 evaluate (&analysis.noise1=&rfree_noise1)
!ARIA2 evaluate (&analysis.noise2=&rfree_noise2)
!ARIA2 evaluate (&analysis.fitselect_ordered=&fitselect_ordered)
!ARIA2 evaluate (&analysis.fitselect_all=&fitselect_all)

set message on echo on end



